### 问题描述

矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为==左下角==的坐标，(x2, y2) 是==右上角==的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果

来源：[Leetcode](https://leetcode-cn.com/problems/rectangle-overlap/description/)

#### 示例

> 示例 1：
> 
> 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
> 输出：true
> 
> 
> 示例 2：
> 
> 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
> 输出：fals


### 解决
#### 思路

> 1. 两个距形不重合的情况，一个距形分别在另一个左侧，右侧，上侧，下侧
>
> 2. 两个距形重合必定后重合的距形，将两个距形投影到 x, y 轴，线段存在交集

#### 代码
```c++
class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        // 思路1 : 排除不重合的情况，全部都在外侧
            // 右上角 x <= 左下角 x  左侧
            // 右上角 y <= 左下角 y  下侧
            // 左下角 y >= 右上角 y  上侧
            // 左下角 x >= 右上角 x  右侧
#if 0
        return !(   rec1[2] <= rec2[0] ||
                    rec1[3] <= rec2[1] ||
                    rec1[1] >= rec2[3] ||
                    rec1[0] >= rec2[2]   );
#else

        /* ----------------------------  分割线  ------------------------------- */
        // 思路2 : 重合一定会有重合的距形，投影到 x 轴有交集，投影到 y 轴有交集
        return (   max(rec1[0], rec2[0]) < min(rec1[2], rec2[2])   // x 轴有交集
                && max(rec1[1], rec2[1]) < min(rec1[3], rec2[3])); // y 轴有交集

#endif
    }
};
```


